import re
from datetime import datetime
from message_analyser.myMessage import MyMessage
from message_analyser.misc import log_line


def get_mymessages_from_file(your_name, target_name, opt_file_name):
    """Retrieves a list of MyMessage representations of messages from a file generated by VkOpt GChrome extension.

    Notes:
        You must firstly ensure that your_name and target_name are equal to the names in opt_file_name text file.

    Args:
        your_name (str): Your name.
        target_name (str): Target's name.
        opt_file_name (str): The name of the file to read.

    Returns:
        A list of MyMessage objects.
    """
    log_line("Start reading vkOpt messages")
    with open(opt_file_name, 'r', encoding="utf8") as f:
        lines = f.readlines()
    opt_message_list = _parse_lines(lines, your_name, target_name)
    msgs = [_opt_to_mymessage(msg) for msg in opt_message_list]
    log_line(len(opt_message_list), " vkOpt messages were received.")
    return msgs


def _opt_to_mymessage(msg):
    """Transforms dictionary representation of the VkOpt message to the MeMessage obj.

    Notes:
        Document id of a VkOpt message isn't parsed and may only be -1.
        Photos aren't documents (for some reason).
        Message is forwarded if only it has attached forwarded messages and doesn't contain any text.

    Args:
        msg (dict): Representation of a VkOpt message.

    Returns:
        MyMessage representation of vkOpt message
    """
    return MyMessage(text=msg["text"], date=msg["date"],
                     author=msg["author"],
                     has_sticker=msg["attachment"].startswith("{\"type\":\"sticker\""),
                     is_forwarded=msg["has_forwards"] and not msg["text"],
                     document_id=-1 if msg["attachment"] and not msg["attachment"].startswith(
                         "vk.com/photo") else None,
                     has_photo=msg["attachment"].startswith("vk.com/photo"),
                     has_voice=("audio_msg.opus" in msg["attachment"]) or
                               ("voice_message.webm" in msg["attachment"]) or
                               ("audiocomment.3gp" in msg["attachment"]),
                     has_audio=msg["attachment"].startswith("vk.com/audio"),
                     has_video=False,  # msg["attachment"].startswith("vk.com/video"),
                     # vk.com doesn't have video messages in the way Telegram does.
                     is_link=True if (msg["attachment"].startswith("{\"type\":\"wall\"") or
                                      msg["attachment"].startswith("{\"type\":\"link\"")) else None)


def _parse_lines(lines, your_name, target_name, num=1000000):
    """Parses given text lines and retrieves a message list.

    Notes:
        Parses messages from vkOpt GChrome extension with a DEFAULT message format.
        Appropriate message format is "%username% (%date%):
                                       %message%"
        Appropriate datetime format is "HH:MM:ss  dd/mm/yyyy".
        More than one nested forwarded messages are counted as ONE forwarded message.
        ... As well as a message with multiple photos counts as ONE photo.
        ... As well as a message with multiple audio files ... what the heck?

    Args:
        your_name (str): Your name.
        target_name (str): Target's name.
        lines (list of strings): Text lines of the file.
        num (int): Max number of the messages to retrieve.

    Returns:
        List of dictionaries such as:
            {
                "text": text of the message (str),
                "has_forwards": flag (bool),
                "attachment": text (str) of the attachment (without first line)
            }
    """
    lines[0] = lines[0].replace('\ufeff', '')  # remove start character
    # assert lines[0].startswith(target_name) or lines[0].strip().startswith(your_name)
    date_pattern = "[0-2][0-9]:[0-5][0-9]:[0-5][0-9]  [0-3][0-9]/[0-1][0-9]/([0-9]{4})"
    date_regex = re.compile(date_pattern)
    title_ending_regex = re.compile(" \(" + date_pattern + "\):\n$")
    msg_title_regex = re.compile("^\t*(" + your_name + '|' + target_name + ") \(" + date_pattern + "\):\n$")
    msgs = []
    current_msg = {"text": "", "has_forwards": False, "attachment": ""}
    i = 0
    while i < len(lines) and len(msgs) <= num:
        line = lines[i]
        if line.startswith("Attachments:["):
            i += 1
            current_msg["attachment"] = lines[i]
        else:
            search = title_ending_regex.search(line)
            if search is not None and search.span()[1] == len(line):
                if line[0].isspace():
                    current_msg["has_forwards"] = True
                    i += 1
                else:
                    if not msg_title_regex.match(line):
                        log_line(f"[{line}] DOES NOT MATCH ANY SUGGESTED NAME! NO VK OPT MESSAGES WILL BE RECEIVED!")
                        return []
                    # removing redundant spaces after the message
                    current_msg["text"] = current_msg["text"][:-3]
                    msgs.append(current_msg)
                    current_msg = {"text": "", "has_forwards": False, "attachment": ""}
                    current_msg["date"] = datetime.strptime(date_regex.search(line).group(), "%H:%M:%S  %d/%m/%Y")
                    current_msg["author"] = your_name if line.startswith(your_name) else target_name
            elif not current_msg["has_forwards"]:
                if current_msg["attachment"]:
                    current_msg["attachment"] += line
                else:
                    current_msg["text"] += line
        i += 1
    if i > 0:
        current_msg["text"] = current_msg["text"] if current_msg["attachment"] else current_msg["text"][:-3]
        msgs.append(current_msg)
    # first message is just a template and should be removed
    return msgs[1:]
